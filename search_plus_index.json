{"./":{"url":"./","title":"简介","keywords":"","body":"简介 愿景 abtool旨在提供基于Unity资源封装格式AssetBundle的C++开发框架以及预置工具集合，方便针对资源做任意的检测、编辑以及资源问题定位。 开发背景 笔者2020年初加入使命召唤手游项目，这是一款偏向内容运营的高品质手机游戏，有非常多的ab资源，从笔者加入项目时的1G左右增加到现在的5G左右，未来可以预期持续的增长。伴随着资源量的增加，资源相关的崩溃、显示问题越来越多，定位解决这些问题是一个常态化的工作。 笔者的工作内容主要是负责版本以及资源发布，在abtool出现之前定位这些问题非常困难，特别是资源引起的游戏崩溃问题，困难主要表现为： 需要稳定的重现方法，通常需要花很多时间去摸索 需要增加运行时调试信息来辅助判断，甚至需要真机调试，通常需要重新构建 处理这类问题遇到最大的麻烦是：即使解决了崩溃，你仍然无法确定是否还有其他类似的资源崩溃问题。我们有7000个左右的ab文件，排查所有的资源问题犹如大海捞针，每次发版本都是战战兢兢、如履薄冰，并且经常通宵攻坚，但也不总是有效，这种情况下只能延迟版本发布。 鉴于笔者丰富的工具开发经验，经历几次通宵后，笔者决定通过工具化寻求突破，最终的开发进度以及使用效果也是十分喜人，截止文档撰写日起已有20多个内置命令，它们均是在解决资源问题过程中逐渐增加和完善的，具有很强的实用性。当然，通过后续的章节了解熟悉后，你也可以轻易开发出专属于你的工具命令。 文档更新 如果你需要访问最新的文档内容，建议你查阅在线文档版本1，或者手动下载当前文档的最新版本2。 由于文档撰写比较匆忙，难免有所谬误，请多包涵。同时，也欢迎大家Fork笔者的文档仓库3并提交相应的PR，让我们一起来完善它，感激不尽！ 1. https://larryhou.github.io/abtool-gitbook/ ↩ 2. https://larryhou.github.io/abtool-gitbook/book.pdf ↩ 3. https://github.com/larryhou/abtool-gitbook/ ↩ console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"chaps/start/":{"url":"chaps/start/","title":"第一章 编译安装","keywords":"","body":"第一章 编译安装 由于笔者日常工作环境中很少使用其他操作系统，暂时abtool只支持针对macOS系统平台的编译运行，感兴趣的朋友可以自行适配其他系统平台，涉及平台差异的内容主要是以下几个外部链接库： libreadline.tbd libfbxsdk.a Foundation.framework libiconv.tbd libxml2.tbd libz.tbd abtool源码基于C++14标准库实现，理论上处理好这些编译依赖问题即可完成适配。 首次编译 如果你不是第一次使用abtool，也就是说你手上已经有了一份abtool工具，那么可以跳过该步骤，直接进行下一步操作。 Xcode编译 打开Xcode，使用组合键⌘+B即可进行源码编译，之后编译可以在终端环境或者shell脚本里面随意使用，这是生成abtool工具的最简单的方式，需要注意的是请确保目标目录/usr/local/bin已被预先创建。 CMake编译 执行如下脚本，即可在build/bin目录得到abtool命令行工具。 # 当前cd目录为工程根目录 mkdir build cd build cmake .. cmake --build . 生成TypeTree数据 TypeTree记录了资源对象数据的序列化信息，收集TypeTree的目的是为了把Unity的类型信息集成到abtool工具里面，只有这样abtool才有可能实现它的功能。 为了让大家快速体验整个工具编译过程，笔者在工程doc目录准备了QuickStart.unitypackage资源包，现在你只需要新建一个Unity工程，然后导入所有资源，通过Unity菜单abtool/Build Asset Bundles即可快速生成包含了TypeTree数据的ab文件，该资源包包含了能够让abtool源码正常编译的最小集合，具体来说是，资源里面包含了以下编译必须的资源对象类型： GameObject RectTransform Transform TextAsset Texture2D Cubemap Material Shader SpriteRenderer SkinnedMeshRenderer MeshRenderer ParticleSystemRenderer LineRenderer TrailRenderer MeshFilter Animator Mesh 如果你现有的项目资源已经覆盖了以上资源类型，那么可以放心使用abtool收集相应的TypeTree数据。然而QuickStart资源包只是覆盖了最小集合的资源类型，如果需要最大限度发挥abtool的功效，笔者强烈建议你扫描尽可能多的ab文件，从而可以收集到尽可能多的Unity类型数据，这样会让你定位资源问题更加得心应手，相信你在后续的日常使用中会深刻明白这一点。 # doc/resources目录存储了QuickStart资源编译的iOS/Android双平台的ab文件 cd doc/resources # 由于QuickStart生成的ab文件后缀为ab，所以可以通过'*.ab'进行文件匹配 # 请根据实际项目的ab文件后缀做适当修改 find . -iname '*.ab' | xargs abtool savetree -a types.tte 上述脚本通过find命令查找所有的ab文件，并把这些文件通过xargs透传给abtool工具去处理，最终会在当前目录生成types.tte文件（当然也可以通过savetree的-a参数指定其他保存目录），这就是我们需要的Unity类型数据。 生成对象序列化代码 types.tte是个二进制文件，把它转换成C++代码才能最终为abtool所用，通过下面这行命令可以轻松完成这个任务，整个过程就好比使用protoc编译*.proto文件一样。 # 当前cd目录为工程根目录 abtool gtt -a doc/resources/types.tte -o abtool/assetbundles/unity 由于上面的脚本是在工程根目录执行，并且代码的输出目录为abtool/assetbundles/unity，所以当脚本执行完成后工程的代码就得到了更新。 最终编译 通过上一步骤我们修改了Unity资源对象的序列化代码，所以还需要再次编译，这样我们就最终得到了功能完备的abtool，通过后续的章节可以逐渐窥探它强大的威力。 什么情况下需要重新编译abtool? 升级了Unity版本 修改了Unity源码里面涉及资源对象的序列化的代码 修改了AssetBundleArchive容器存储结构 修改了SerializedFile存储结构 如果需要abtool正常处理所有MonoBehaviour组件数据，那么你需要定期编译abtool，不过我们大部分情况下并不关心这部分数据。 运行测试 当你不知道用abtool做什么的时候，建议你跑一下dump命令，如下 abtool dump doc/resources/android/quickstart.ab console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"chaps/cases/":{"url":"chaps/cases/","title":"第二章 应用案例","keywords":"","body":"第二章 应用案例 对于大多数来说，大家可能更希望abtool能有一些现实的应用场景，这样拿到工具后就可以着手做一些资源侧的检测优化工作，在本章节会列举几个常见的案例，通过案例来了解工具的使用。 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"chaps/cases/case_reverse/":{"url":"chaps/cases/case_reverse/","title":"资源逆向","keywords":"","body":"资源逆向 资源逆向既是通常意义的资源反编译，也就是从ab文件里面提取出来方便浏览的资源。鉴于abtool集成了项目所有资源类型的序列化信息，理论上abtool可以反编译任意资源，但是实现情况是反编译所有资源有代价，并且也不是所有资源都是我们关心的，所以笔者暂时只实现了有限几个但高频使用的资源类型的反编译，比如：贴图、模型、Shader、二进制文件等。从ab文件反编译资源并非abtool的开发初衷，但是abtool的实现原理注定它可以轻松支持资源逆向目的。 为了增加abtool资源逆向功能的一般性，笔者选择在本案例中使用第三方线上运营游戏来做演示，大家可以依照步骤得到相同的结果。 声明：本案例使用的方法以及由该方法得到的资源仅用于学习交流，请勿用于其他非法目的，否则后果自负。 下载安装包 我们可以通过Google搜索战歌竞技场 apk，然后下载相应的apk安装包。笔者使用的版本是1.5.151，点击链接1可直接进行下载，但是鉴于cdn链接的时效性，该文档并不保证该下载链接总是有效可用，如果下载失败请自行从Google搜索结果里面寻找其他链接进行下载。 解压ab资源 首先，用unzip命令行查看apk资源列表 unzip -l 10040714_com.tencent.hjzqgame_a960942_1.5.151_j2e715.apk 从日志里面我们发现assets/AssetBundles目录存储了ab资源，现在我们可以继续用unzip提取ab资源 unzip -o 10040714_com.tencent.hjzqgame_a960942_1.5.151_j2e715.apk 'assets/AssetBundles/*' cd assets 这样我们就得到了apk里面所有的ab资源，在后续资源资源逆向案例中如无特殊说明，均把解压出来的assets目录作为工具的工作空间，并默认使用AssetBundles目录里面的ab资源做演示。 编译 我们在前面章节已经学习了工具编译过程，由于该案例用到的ab资源属于某个特定Unity版本，所以需要依据编译流程手机资源TypeTree并重新编译abtool，否则您将无法正常通过abtool进行后续的资源逆向操作。 find . -iname '*.god' | xargs abtool savetree 1. https://dlied4.myapp.com/myapp/1109006800/cos.release-75620/10040714_com.tencent.hjzqgame_a960942_1.5.151_j2e715.apk ↩ console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"chaps/cases/case_reverse/texture.html":{"url":"chaps/cases/case_reverse/texture.html","title":"贴图","keywords":"","body":"贴图 选择ab文件 首先我们需要找到一个包含贴图资源的ab文件，如果您不确定是哪个ab满足要求，那么可以使用list命令收集所有进包的资源路径，然后反过来从贴图资源的路径查找相应的ab文件。 find AssetBundles -iname '*.god' | xargs abtool list -r 从结果里面我们选择artresource_captainpbr_captain_202.god作为演示资源。 提取贴图资源 通过abtool的savetex命令可以一次性保存ab文件里面所有的贴图资源，默认输出到当前目录的__textures目录，也可以添加--output参数指定其他存放目录。 abtool savetex AssetBundles/Android/artresource_captainpbr_captain_202.god 需要说明的是：savetex保存的贴图有着固定命名规范，其格式为[filename].[宽]x[高].[贴图格式].tex，除了filename，其余文件名内容是不能修改的，否则在接下来的贴图转码操作会失败。 贴图格式转换 从上一步骤得到的贴图都是*.tex格式的文件，并非用普通图片浏览工具可以直接查看文件格式，它们被做了特殊编码编码以便GPU渲染时可以被正常读取，所以还需要做贴图转码。在工程根目录放置了python脚本工具textool.py，它可以批量地把*.tex文件转换成项目中常见的*.tga文件。 import re, struct from tex2img import decompress_astc, decompress_etc, decompress_pvrtc from PIL import Image def main(): import sys pattern = re.compile(r'[^/]+\\.(\\d+x\\d+)\\.([^.]+)\\.tex$') for filename in sys.argv[1:]: match = pattern.search(filename) if not match: continue # print('>>> {}'.format(filename)) fp = open(filename, 'rb') texture_size = [int(x) for x in match.group(1).split('x')] texture_format = match.group(2) mode = 'RGBA' if texture_format.startswith('etc_'): image = decompress_etc(fp.read(), texture_size[0], texture_size[1], 0) mode = 'RGB' elif texture_format.startswith('etc2_'): image = decompress_etc(fp.read(), texture_size[0], texture_size[1], 3 if texture_format.startswith('etc2_rgba') else 1) elif texture_format.startswith('astc_rgb'): block_size = [int(x) for x in texture_format.split('_')[-1].split('x')] image = decompress_astc(fp.read(), texture_size[0], texture_size[1], block_size[0], block_size[1], False) elif texture_format.startswith('pvrtc'): # https://github.com/powervr-graphics/Native_SDK/blob/3f88b0f3735774ab9fb718da0aeadd06acf68d21/framework/PVRCore/texture/PVRTDecompress.cpp#L574 image = decompress_pvrtc(fp.read(), texture_size[0], texture_size[1], 0 if texture_format[-1] == '4' else 1) elif texture_format.startswith('rgba32'): image = fp.read() elif texture_format.startswith('rgb24'): image = fp.read() mode = 'RGB' elif texture_format.startswith('rgb565'): width, height = texture_size image = bytearray(width * height * 3) index = 0 for r in range(height): for c in range(width): v, = struct.unpack('> 11 & 0x1F) * 255 // 0x1F # red image[index+1] = (v >> 5 & 0x3F) * 255 // 0x3F # green image[index+2] = (v >> 0 & 0x1F) * 255 // 0x1F # blue index += 3 image = bytes(image) mode = 'RGB' elif texture_format.startswith('rgba4444'): width, height = texture_size image = bytearray(width * height * 4) index = 0 for r in range(height): for c in range(width): v, = struct.unpack('> 12 & 0xF) * 255 // 0xF # red image[index+1] = (v >> 8 & 0xF) * 255 // 0xF # green image[index+2] = (v >> 4 & 0xF) * 255 // 0xF # blue image[index+3] = (v >> 0 & 0xF) * 255 // 0xF # alpha index += 4 image = bytes(image) elif texture_format.startswith('alpha8'): image = fp.read() mode = 'L' else: continue result = Image.frombytes(mode, tuple(texture_size), image, 'raw') savename = re.sub(r'(\\.[^.]+){3}$', '', filename) + '.tga' result.save(savename) print('+ {} => {}'.format(filename, savename)) if __name__ == '__main__': main() 在使用前建议把textool放到/usr/bin/local/目录下，这样好处是不用每次都用一个很长的路径来访问这个工具了。 cp -fv textool.py /usr/local/bin/textool 接下来通过textool转换*.tex贴图格式，转换后的图片文件存储在源*.tex文件的同级目录。 textool __textures/*.tex 打开__textures目录见证奇迹时刻。 textool工具依赖第三方贴图解码库tex2img1，该工具封装了BinomialLLC/basis_universal2、Ericsson/ETCPACK3和powervr-graphics/Native_SDK4，感谢老哥K0lb35提供的便利。笔者在此基础上增加了RGBA32、RGBA4444、RGB24、RGB565和Alpha8贴图格式的转码，经过这么一番整合，应该可以应付绝大部分的贴图转码。 1. https://github.com/K0lb3/tex2img.git ↩ 2. https://github.com/BinomialLLC/basis_universal/ ↩ 3. https://github.com/Ericsson/ETCPACK ↩ 4. https://github.com/powervr-graphics/Native_SDK/tree/master/framework/PVRCore/texture ↩ 5. https://github.com/K0lb3 ↩ console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"chaps/cases/case_reverse/model.html":{"url":"chaps/cases/case_reverse/model.html","title":"模型","keywords":"","body":"模型 在该案里面我们继续使用artresource_captainpbr_captain_202.god文件来演示，相比贴图逆向，模型逆向就简单多了，一行命令就可以把ab资源里面的模型导出为*.fbx文件。 $ abtool savefbx AssetBundles/Android/artresource_captainpbr_captain_202.god FBX文件可以通过Autodesk FBX Review1打开 也可以用其他3D工具打开，比如我们可以在Blender里面查看模型的法线、UVs等信息。 结合贴图逆向得到的贴图，那么我们可以尝试用基础贴图Captain_202201_body_b.tga简单渲染一下。 呃，跟预期的好像不太一样，这简直像鬼一样……别着急，把贴图上下翻转下就能正常显示了。 1. https://www.autodesk.com/products/fbx/fbx-review ↩ console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"chaps/cases/case_protect.html":{"url":"chaps/cases/case_protect.html","title":"资源防护","keywords":"","body":"资源防护 通过资源逆向案例我们见识了abtool强大的资源反编译能力，但是这个时候我们不应该兴奋，而是应该无比忧虑才对：因为第三方工具可以在没有项目仓库权限的情况下轻易获取游戏资源，这些都是项目团队日夜攻坚、长时间累积优化的结果，如果被用于非法目的，对游戏是非常不利的。问题来了：既然ab资源如此容易破解，那么该如何保护游戏资产？ 打包ab资源时关掉TypeTree 我们先来看下ab打包接口 public static AssetBundleManifest BuildAssetBundles( string outputPath, AssetBundleBuild[] builds, BuildAssetBundleOptions assetBundleOptions, BuildTarget targetPlatform); 第三个枚举参数BuildAssetBundleOptions用来控制ab的打包行为，其中枚举值DisableWriteTypeTree可以关闭TypeTree。 /// /// Do not include type information within the AssetBundle. /// DisableWriteTypeTree = 8, 由于abtool绝大部分功能都基于TypeTree，那是不是关闭TypeTree资源就安全了？没那么简单！TypeTree是由Unity生成，换句话说，如果拿到相同版本的Unity也是可以轻易获取TypeTree的，在这种情况下，关掉TypeTree的意义仅仅是防止了破解MonoBehaviour，防护等级是很弱的！换句话说，如果您用了Unity公开发行的版本（标准版），那么您的的游戏资产完全是在裸奔的！ 修改关键资源序列化 如果您的项目有源码，那么可以把一些关键资源的序列化字段改一下。比如Texture2D这个资源类型，它的数据结构大致如下 struct Texture2D: public Object { std::string m_Name; // 1 int32_t m_ForcedFallbackFormat; // 2 bool m_DownscaleFallback; // 3 int32_t m_Width; // 4 int32_t m_Height; // 5 int32_t m_CompleteImageSize; // 6 int32_t m_TextureFormat; // 7 int32_t m_MipCount; // 8 bool m_IsReadable; // 9 int32_t m_ImageCount; // 10 int32_t m_TextureDimension; // 11 GLTextureSettings m_TextureSettings; // 12 int32_t m_LightmapFormat; // 13 int32_t m_ColorSpace; // 14 TypelessData m_TexData; // 15 StreamingInfo m_StreamData; // 16 }; 在资源对象序列化过程中，string/map/set/vector等数据类型均被当做数组来处理：先用4字节存储数组长度，然后按顺序存储数组元素，对于string它的数组元素类型是char。基于此，我们可以在标准版的Unity源码里面做一些微小改动，比如把上述类型序列化顺序交换位置，或者在这些字段的序列化之前写入一个很大的整形，这样通过标准版Unity反编译资源就会导致崩溃或者无限循环。该保护措施的本质是修改资源类型的数据结构，使其与标准版Unity生成TypeTree产生差异，从而导致通过标准版Unity破解资源的方法失效。 修改AssetBundleArchive存储结构 每个ab资源在Unity里面会都会通过一个AssetBundleArchive容器来存储，它的作用是压缩资源对象数据并提供文件寻址功能，并没有什么特别的，如果您的项目有源码完全可以自行设计一个实现类似功能的资源容器，比如王者荣耀、原神游戏做了类似的设计。 修改SerializedFile存储结构 除了定制资源容器，还可以通过修改容器内资源的存储方式，比如修改SerializedFile的metadata数据的组织方式。 加密 如果觉得上述源码修改过于复杂，那么可以对ab文件做二进制的加密，也可以选择对其部分内容做加密，前提是不要有过多运行时开销，比如LOL手游做了类似的设计。 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"chaps/cases/case_crash.html":{"url":"chaps/cases/case_crash.html","title":"资源引发崩溃","keywords":"","body":"资源引发崩溃 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"chaps/cases/case_noref.html":{"url":"chaps/cases/case_noref.html","title":"资源引用丢失","keywords":"","body":"资源引用丢失 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"chaps/cases/case_display.html":{"url":"chaps/cases/case_display.html","title":"资源显示异常","keywords":"","body":"资源显示异常 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"chaps/cases/case_compare.html":{"url":"chaps/cases/case_compare.html","title":"资源差异比对","keywords":"","body":"资源差异比对 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"chaps/cases/case_edit.html":{"url":"chaps/cases/case_edit.html","title":"资源编辑","keywords":"","body":"资源编辑 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"chaps/commands/":{"url":"chaps/commands/","title":"第三章 命令详解","keywords":"","body":"第三章 命令详解 截止文档撰写日起已有20多个内置命令，它们均是在解决资源问题过程中逐渐增加和完善的，具有很强的实用性。 颜色高亮 大部分命令运行过程中输出到终端的日志都是有颜色样式的，这个设计主要是根据信息的重要性做不同的高亮突出显示，方便在日志里面找到有用的信息。当然，也强烈建议你把终端设置为黑色背景样式，不然颜色显示会比较奇怪，因为黑色背景为终端显示样式的调试环境。 然而，在有些情况下，我们需要对工具输出的日志做进一步分析，这个时候我们是不希望有颜色高亮的，因为这些颜色都是通过颜色控制符1实现的，这会让日志里面多出一些方括号[的字符，如下图显示看起来比较杂乱，有可能会让下游的分析工具产生不符合预期的结果。 不过工程根目录里的nocolor.cpp的小工具可以轻松去掉终端的颜色样式，该工具含代码格式只有26行C++代码，非常轻量高效。 #include #include int main(int argc, char* argv[]) { std::string pipe; while (std::getline(std::cin, pipe)) { auto cursor = pipe.begin(); for (auto iter = pipe.begin(); iter != pipe.end(); iter++) { if (*iter == '\\e' && *(iter+1) == '[') { ++iter; // [ ++iter; // d ++iter; // m if (*iter != 'm') { ++iter; } continue; } *cursor++ = *iter; } *cursor = 0; std::cout 可以通过如下终端命令快速编译。 clang++ -std=c++11 nocolor.cpp -o/usr/local/bin/nocolor 使用起来也十分方便，只需命令末尾追加管道。 abtool list doc/resources/android/quickstart.ab | nocolor 帮助系统 abtool内置了简单的帮助系统，可以帮助我们快速了解命令功能以及参数，比如可以通过abtool help查看所有命令。 $ abtool help abtool COMMAND file ... Commands: abname : 通过SF路径从*.obj文件解析ab名字 cmpmono : 比对mono命令生成的*.ms文件并生成脚本变更报告 cmpref : 对比saveobj命令生成的*.obj文件并分析对象引用 cmpxtl : 比对external命令生成的*.xtl文件并生成ab依赖变更报告 dump : 生成文本格式的对象数据 edit : 进入交互编辑模式 external : 收集AB外部依赖信息 gencpp : 从AB文件提取TypeTree并生成C++序列化代码 getref : 获取资源引用 gtt : 从序列化的TypeTree文件生成C++代码 help : 获取帮助信息 list : 查看进包资源 lua : 运行LUA脚本 missing : 扫描资源引用丢失 mono : 扫描MonoScript脚本使用信息 rename : 根据AssetBundle::m_Name还原文件名 resolve : 通过SF路径以及m_PathID信息从*.obj文件获取实体资源信息 rmtree : 剔除TypeTree信息 savefbx : 扫描Mesh资源并保存为*.fbx文件 saveobj : 保存对象数据 saveta : 保存TextAsset资源 savetex : 保存Texture2D资源 savetree : 保存TypeTree二进制数据 scanref : 检查资源引用的对象类型是否匹配 scantex : 扫描非标准格式的贴图 size : 生成对象大小简报 test : 序列化正确性测试 textize : 文本化序列化文件并保存文件 abtool命令采用了一致的参数传参设计，可以通过abtool [command] --help查看参数含义， $ abtool savefbx --help -r --axis-rotate-enabled rotate model 90 degrees by axis-X counter-clockwise [FLAG] -o --output *.fbx output path [OPTIONAL](default=__fbx) -w --rewritable rewrite local file if it exists [FLAG] -s --skeleton-enabled include skeleton info in *.fbx [FLAG] [FLAG]表示当前参数为功能开关并且参数没有参数值 [OPTIONAL]表示当前参数为可选参数并有默认值，例如default=__fbx 其他类型的参数为必选参数，也即是参数名和参数值必须设置正确，否则会运行崩溃 在本章节只会对一些常用的命令做详细的说明，其他命令可以自行看源码了解。 1. https://misc.flogisoft.com/bash/tip_colors_and_formatting ↩ console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"chaps/commands/savetree.html":{"url":"chaps/commands/savetree.html","title":"savetree","keywords":"","body":"savetree 用途 savetree可以从SerializedFile的metadata数据区提取资源对象的类型TypeTree，并把二进制TypeTree数据保存到当前目录。 参数 参数 缩写 描述 --artifact -a 指定缓存文件的存储路径，默认：types.tte savetree每次运行时会自动通过-a指定的路径读取缓存配置，并把二次运行得到的数据与缓存数据进行合并，然后在运行结束后把最终的数据存储到参数-a指定的路径。 如果你的项目工程没有包含所有abtool运行所需的必要资源类型，那么可以用你的Unity软件新建一个工程，然后导入QuickStart.unitypackage，并通过Editor菜单abtool/Build Asset Bundles生成对应平台的ab文件quickstart.ab，之后通过savetree第一次生成types.tte，进而在此基础上扫描你的项目ab资源，这样最终得到的TypeTree数据文件就不会缺少相关类型信息了。 示例 # 假设ab资源的文件名为*.ab，请根据实际文件名做适当修改 find . -iname '*.ab' | xargs abtool savetree console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"chaps/commands/gtt.html":{"url":"chaps/commands/gtt.html","title":"gtt","keywords":"","body":"gtt 用途 gtt可以把savetree命令生成类型数据types.tte转换成格式工整的C++代码，分别对应一下工程代码。 abtool/assetbundles/unity/types.hpp：定义资源类型数据结构 abtool/assetbundles/unity/types.cpp：实现资源对象序列化 abtool/assetbundles/unity/luatypes.cpp：实现资源类型的lua绑定 abtool/assetbundles/unity/textize.cpp：实现资源对象dump方法，用来打印对象信息 abtool/assetbundles/unity/compare.cpp：实现对象比对逻辑 参数 参数 缩写 描述 --artifact -a 二进制类型文件路径，默认：types.tte --limit -l 限定类定义数量，避免生成过多代码，默认：400 --output -o 代码输出路径，默认：__types 示例 abtool gtt -a types.tte -o abtool/assetbundles/unity console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"chaps/commands/dump.html":{"url":"chaps/commands/dump.html","title":"dump","keywords":"","body":"dump 用途 dump把SerializedFile包含的对象数据以文本形式打印到标准输出。 参数 无 示例 abtool dump doc/resources/android/quickstart.ab console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"chaps/commands/list.html":{"url":"chaps/commands/list.html","title":"list","keywords":"","body":"list 用途 list统计ab文件包含的资源路径列表以及对象数量，在接力模式下会把相应数据缓存到当前目录的assets.ls文件。 参数 参数 缩写 描述 --enable-relay -r 接力模式开关 --artifact -a 缓存数据文件路径，尽在接力模式下有效，默认：assets.ls 示例 abtool list doc/resources/android/quickstart.ab 接力模式下执行后，在当前目录会得到assets.ls文件。 find doc/resources/android -iname '*.ab' | xargs abtool list -r 接力模式下二次运行命令可以简化为，当前模式下会自动加载assets.ls文件，并打印相关信息。 abtool list -r console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"chaps/commands/size.html":{"url":"chaps/commands/size.html","title":"size","keywords":"","body":"size 用途 size命令统计资源对象序列化数据大小的分布情况。 参数 无 示例 abtool size doc/resources/ios/quickstart.ab 如果所示，除了不同资源对象大小，还会针对贴图输出详细报告。 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"chaps/commands/scanref.html":{"url":"chaps/commands/scanref.html","title":"scanref","keywords":"","body":"scanref 用途 scanref命令通过扫描ab资源的对象之间的引用关系来识别资源引用的有效性，同时会把扫描结果缓存到当前目录的assets.ref文件。 参数 参数 缩写 描述 --artifact -a 缓存文件路径，默认：assets.ref 示例 find . -iname '*.god' | xargs abtool scanref 再次运行该命令时可以简化为，当前模式下会自动加载assets.ref文件，并打印相关信息，如下。 上图显示，ab资源scene_guanghanpalace.god引用了另外一个ab文件prefabs_effects.god里面m_PathID=12602647748065502323的材质球，但是prefabs_effects.god文件里面并没有这个资源。 missing状态的资源问题只会导致显示问题，比如紫块、白模等。下图为前文崩溃案例的扫描结果，其主要特征是被引用的资源对象的期望类型与实际类型不符，会导致运行时发生不同类型的强转而导致崩溃。 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"chaps/commands/scantex.html":{"url":"chaps/commands/scantex.html","title":"scantex","keywords":"","body":"scantex 用途 scantex命令扫描ab文件里面包含贴图资源并识别非渲染高效(PVRTC/ASTC/ETC[2])的贴图，同时会把扫描结果缓存到当前目录的textures.tex文件。 参数 参数 缩写 描述 --artifact -a 缓存文件路径，默认：textures.tex --verbose -v 更多日志开关 示例 find . -iname '*.god' | xargs abtool scantex 再次运行该命令时可以简化为，当前模式下会自动加载textures.tex文件，并打印相关信息，如下。 从上图可以发现有不少POT正方形贴图却设置为RGBA32格式，这是非常不明智的，因为这种贴图格式的渲染效率很差：占用内存高并且导致渲染发热问题。 另外，该命令在-v开关下会输出所有贴图信息，如下。 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"chaps/commands/savefbx.html":{"url":"chaps/commands/savefbx.html","title":"savefbx","keywords":"","body":"savefbx 用途 savefbx命令扫描ab文件里面所有Mesh资源对象并保存为*.fbx文件，用Mesh::m_Name作为文件名。需要注意的是，该命令从Mesh::m_CompressedMesh字段提取模型数据，如果该字段没有包含有效模型数据，最终保存的文件是无效的。 struct Mesh: public Object { std::string m_Name; // 1 std::vector m_SubMeshes; // 2 BlendShapeData m_Shapes; // 3 std::vector m_BindPose; // 4 std::vector m_BoneNameHashes; // 5 uint32_t m_RootBoneNameHash; // 6 uint8_t m_MeshCompression; // 7 bool m_IsReadable; // 8 bool m_KeepVertices; // 9 bool m_KeepIndices; // 10 int32_t m_IndexFormat; // 11 std::vector m_IndexBuffer; // 12 std::vector m_Skin; // 13 VertexData m_VertexData; // 14 CompressedMesh m_CompressedMesh; // 15 AABB m_LocalAABB; // 16 int32_t m_MeshUsageFlags; // 17 std::vector m_BakedConvexCollisionMesh; // 18 std::vector m_BakedTriangleCollisionMesh; // 19 }; 模型压缩设置 参数 参数 缩写 描述 --axis-rotate-enabled -r 沿X轴逆时针旋转模型90°开关 --output -o *.fbx文件输出目录，默认：__fbx --rewritable -w 文件保存覆盖开关 --skeleton-enabled -s 保存文件包含骨骼蒙皮信息开关 示例 abtool savefbx Android/artresource_captainpbr_captain_201.god console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"chaps/commands/savetex.html":{"url":"chaps/commands/savetex.html","title":"savetex","keywords":"","body":"savetex 用途 savetex命令扫描ab文件里面所有Texture2D资源对象并保存为*.tex文件，用Texture2D::m_Name作为文件名前缀，同时追加贴图尺寸以及格式信息。 参数 参数 缩写 描述 --output -o *.tex文件输出目录，默认：__textures 示例 abtool savetex Android/artresource_captainpbr_captain_201.god 由于savetex提取出来贴图都是非常见编码格式，通常需要配合工程根目录的python工具textool一起使用，主要作用是把贴图转码为TGA格式，如下。 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"chaps/commands/saveta.html":{"url":"chaps/commands/saveta.html","title":"saveta","keywords":"","body":"saveta 用途 saveta命令扫描ab文件里面所有TextAsset资源对象并保存到当前cd目录的__textassets目录。该命令首先通过容器AssetBundle::m_Container尝试还原二进制文件的原始后缀，如果未找到任何匹配则使用dat作为文件后缀保存。 struct AssetBundle: public Object { std::string m_Name; // 1 std::vector> m_PreloadTable; // 2 std::multimap m_Container; // 3 AssetInfo m_MainAsset; // 4 uint32_t m_RuntimeCompatibility; // 5 std::string m_AssetBundleName; // 6 std::vector m_Dependencies; // 7 bool m_IsStreamedSceneAssetBundle; // 8 int32_t m_ExplicitDataLayout; // 9 int32_t m_PathFlags; // 10 std::map m_SceneHashes; // 11 }; 参数 参数 缩写 描述 --output -o 文件输出目录，默认：__textassets 示例 abtool saveta Android/dataconfig.god console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"chaps/commands/saveobj.html":{"url":"chaps/commands/saveobj.html","title":"saveobj","keywords":"","body":"saveobj 用途 saveobj提取资源对象的简要信息并默认保存到当前cd目录的objects.obj文件，主要为getref、cmpref、resolve、abname等命令提供基础数据。 参数 参数 缩写 描述 --artifact -a 文件的存储路径，默认：objects.obj saveobj每次运行时会自动通过-a指定的路径读取文件保存路径，并把二次运行得到的数据与缓存数据进行合并，然后在运行结束后把最终的数据存储到参数-a指定的路径。 示例 # 假设ab资源的文件名为*.ab，请根据实际文件名做适当修改 find . -iname '*.ab' | xargs abtool saveobj console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"chaps/commands/objref.html":{"url":"chaps/commands/objref.html","title":"objref","keywords":"","body":"objref console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"chaps/commands/mono.html":{"url":"chaps/commands/mono.html","title":"mono","keywords":"","body":"mono console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"chaps/commands/cmpref.html":{"url":"chaps/commands/cmpref.html","title":"cmpref","keywords":"","body":"cmpref console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"chaps/commands/cmpxtl.html":{"url":"chaps/commands/cmpxtl.html","title":"cmpxtl","keywords":"","body":"cmpxtl console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"chaps/commands/cmphash.html":{"url":"chaps/commands/cmphash.html","title":"cmphash","keywords":"","body":"cmphash console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"chaps/commands/external.html":{"url":"chaps/commands/external.html","title":"external","keywords":"","body":"external console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"chaps/commands/rmtree.html":{"url":"chaps/commands/rmtree.html","title":"rmtree","keywords":"","body":"rmtree console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"chaps/commands/lua.html":{"url":"chaps/commands/lua.html","title":"lua","keywords":"","body":"lua console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"chaps/commands/edit.html":{"url":"chaps/commands/edit.html","title":"edit","keywords":"","body":"edit console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"chaps/developments/":{"url":"chaps/developments/","title":"第四章 进阶开发","keywords":"","body":"第四章 进阶开发 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"chaps/developments/project.html":{"url":"chaps/developments/project.html","title":"项目架构","keywords":"","body":"项目架构 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"chaps/developments/coding.html":{"url":"chaps/developments/coding.html","title":"文件解析","keywords":"","body":"文件解析 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"chaps/developments/serialization.html":{"url":"chaps/developments/serialization.html","title":"对象序列化","keywords":"","body":"对象序列化 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"chaps/developments/command.html":{"url":"chaps/developments/command.html","title":"命令系统","keywords":"","body":"命令系统 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"chaps/developments/filesystem.html":{"url":"chaps/developments/filesystem.html","title":"文件系统","keywords":"","body":"文件系统 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"chaps/developments/lua.html":{"url":"chaps/developments/lua.html","title":"LUA绑定","keywords":"","body":"LUA绑定 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"chaps/cases/reverse/":{"url":"chaps/cases/reverse/","title":"资源逆向","keywords":"","body":"资源逆向 资源逆向既是通常意义的资源反编译，也就是从ab文件里面提取出来方便浏览的资源。鉴于abtool集成了项目所有资源类型的序列化信息，理论上abtool可以反编译任意资源，但是实现情况是反编译所有资源有代价，并且也不是所有资源都是我们关心的，所以笔者暂时只实现了有限几个但高频使用的资源类型的反编译，比如：贴图、模型、Shader、二进制文件等。从ab文件反编译资源并非abtool的开发初衷，但是abtool的实现原理注定它可以轻松支持资源逆向目的。 为了增加abtool资源逆向功能的一般性，笔者选择在本案例中使用第三方线上运营游戏来做演示，大家可以依照步骤得到相同的结果。 声明：本案例使用的方法以及由该方法得到的资源仅用于学习交流，请勿用于其他非法目的，否则后果自负。 下载安装包 我们可以通过Google搜索战歌竞技场 apk，然后下载相应的apk安装包。笔者使用的版本是1.5.151，点击链接1可直接进行下载，但是鉴于cdn链接的时效性，该文档并不保证该下载链接总是有效可用，如果下载失败请自行从Google搜索结果里面寻找其他链接进行下载。 解压ab资源 首先，用unzip命令行查看apk资源列表 unzip -l 10040714_com.tencent.hjzqgame_a960942_1.5.151_j2e715.apk 从日志里面我们发现assets/AssetBundles目录存储了ab资源，现在我们可以继续用unzip提取ab资源 unzip -o 10040714_com.tencent.hjzqgame_a960942_1.5.151_j2e715.apk 'assets/AssetBundles/*' cd assets 这样我们就得到了apk里面所有的ab资源，在后续资源资源逆向案例中如无特殊说明，均把解压出来的assets目录作为工具的工作空间，并默认使用AssetBundles目录里面的ab资源做演示。 编译 我们在前面章节已经学习了工具编译过程，由于该案例用到的ab资源属于某个特定Unity版本，所以需要依据编译流程手机资源TypeTree并重新编译abtool，否则你将无法正常通过abtool进行后续的资源逆向操作。 find . -iname '*.god' | xargs abtool savetree 1. https://dlied4.myapp.com/myapp/1109006800/cos.release-75620/10040714_com.tencent.hjzqgame_a960942_1.5.151_j2e715.apk ↩ console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"chaps/cases/reverse/texture.html":{"url":"chaps/cases/reverse/texture.html","title":"贴图","keywords":"","body":"贴图 选择ab文件 首先我们需要找到一个包含贴图资源的ab文件，如果你不确定是哪个ab满足要求，那么可以使用list命令收集所有进包的资源路径，然后反过来从贴图资源的路径查找相应的ab文件。 find AssetBundles -iname '*.god' | xargs abtool list -r 从结果里面我们选择artresource_captainpbr_captain_202.god作为演示资源。 提取贴图资源 通过abtool的savetex命令可以一次性保存ab文件里面所有的贴图资源，默认输出到当前目录的__textures目录，也可以添加--output参数指定其他存放目录。 abtool savetex AssetBundles/Android/artresource_captainpbr_captain_202.god 需要说明的是：savetex保存的贴图有着固定命名规范，其格式为[filename].[宽]x[高].[贴图格式].tex，除了filename，其余文件名内容是不能修改的，否则在接下来的贴图转码操作会失败。 贴图格式转换 从上一步骤得到的贴图都是*.tex格式的文件，并非用普通图片浏览工具可以直接查看文件格式，它们被做了特殊编码编码以便GPU渲染时可以被正常读取，所以还需要做贴图转码。在工程根目录放置了python脚本工具textool.py，它可以批量地把*.tex文件转换成项目中常见的*.tga文件。 import re, struct from tex2img import decompress_astc, decompress_etc, decompress_pvrtc from PIL import Image def main(): import sys pattern = re.compile(r'[^/]+\\.(\\d+x\\d+)\\.([^.]+)\\.tex$') for filename in sys.argv[1:]: match = pattern.search(filename) if not match: continue # print('>>> {}'.format(filename)) fp = open(filename, 'rb') texture_size = [int(x) for x in match.group(1).split('x')] texture_format = match.group(2) mode = 'RGBA' if texture_format.startswith('etc_'): image = decompress_etc(fp.read(), texture_size[0], texture_size[1], 0) mode = 'RGB' elif texture_format.startswith('etc2_'): image = decompress_etc(fp.read(), texture_size[0], texture_size[1], 3 if texture_format.startswith('etc2_rgba') else 1) if not texture_format.startswith('etc2_rgba'): mode = 'RGB' elif texture_format.startswith('astc_rgb'): block_size = [int(x) for x in texture_format.split('_')[-1].split('x')] image = decompress_astc(fp.read(), texture_size[0], texture_size[1], block_size[0], block_size[1], False) elif texture_format.startswith('pvrtc'): # https://github.com/powervr-graphics/Native_SDK/blob/3f88b0f3735774ab9fb718da0aeadd06acf68d21/framework/PVRCore/texture/PVRTDecompress.cpp#L574 image = decompress_pvrtc(fp.read(), texture_size[0], texture_size[1], 0 if texture_format[-1] == '4' else 1) elif texture_format.startswith('rgba32'): image = fp.read() elif texture_format.startswith('rgb24'): image = fp.read() mode = 'RGB' elif texture_format.startswith('rgb565'): width, height = texture_size image = bytearray(width * height * 3) index = 0 for r in range(height): for c in range(width): v, = struct.unpack('> 11 & 0x1F) * 255 // 0x1F # red image[index+1] = (v >> 5 & 0x3F) * 255 // 0x3F # green image[index+2] = (v >> 0 & 0x1F) * 255 // 0x1F # blue index += 3 image = bytes(image) mode = 'RGB' elif texture_format.startswith('rgba4444'): width, height = texture_size image = bytearray(width * height * 4) index = 0 for r in range(height): for c in range(width): v, = struct.unpack('> 12 & 0xF) * 255 // 0xF # red image[index+1] = (v >> 8 & 0xF) * 255 // 0xF # green image[index+2] = (v >> 4 & 0xF) * 255 // 0xF # blue image[index+3] = (v >> 0 & 0xF) * 255 // 0xF # alpha index += 4 image = bytes(image) elif texture_format.startswith('alpha8'): image = fp.read() mode = 'L' else: continue result = Image.frombytes(mode, tuple(texture_size), image, 'raw') savename = re.sub(r'(\\.[^.]+){3}$', '', filename) + '.tga' result.save(savename) print('+ {} => {}'.format(filename, savename)) if __name__ == '__main__': main() 在使用前建议把textool放到/usr/bin/local/目录下，这样好处是不用每次都用一个很长的路径来访问这个工具了。 cp -fv textool.py /usr/local/bin/textool 接下来通过textool转换*.tex贴图格式，转换后的图片文件存储在源*.tex文件的同级目录。 textool __textures/*.tex 打开__textures目录见证奇迹时刻。 textool工具依赖第三方贴图解码库tex2img1，该工具封装了BinomialLLC/basis_universal2、Ericsson/ETCPACK3和powervr-graphics/Native_SDK4，感谢老哥K0lb35提供的便利。笔者在此基础上增加了RGBA32、RGBA4444、RGB24、RGB565和Alpha8贴图格式的转码，经过这么一番整合，应该可以应付绝大部分的贴图转码。 1. https://github.com/K0lb3/tex2img.git ↩ 2. https://github.com/BinomialLLC/basis_universal/ ↩ 3. https://github.com/Ericsson/ETCPACK ↩ 4. https://github.com/powervr-graphics/Native_SDK/tree/master/framework/PVRCore/texture ↩ 5. https://github.com/K0lb3 ↩ console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"chaps/cases/reverse/model.html":{"url":"chaps/cases/reverse/model.html","title":"模型","keywords":"","body":"模型 在该案里面我们继续使用artresource_captainpbr_captain_202.god文件来演示，相比贴图逆向，模型逆向就简单多了，一行命令就可以把ab资源里面的模型导出为*.fbx文件。 $ abtool savefbx AssetBundles/Android/artresource_captainpbr_captain_202.god FBX文件可以通过Autodesk FBX Review1打开 也可以用其他3D工具打开，比如我们可以在Blender里面查看模型的法线、UVs等信息。 结合贴图逆向得到的贴图，那么我们可以尝试用基础贴图Captain_202201_body_b.tga简单渲染一下。 呃，跟预期的好像不太一样，这简直像鬼一样……别着急，把贴图上下翻转下就能正常显示了。 1. https://www.autodesk.com/products/fbx/fbx-review ↩ console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"chaps/cases/protect.html":{"url":"chaps/cases/protect.html","title":"资源防护","keywords":"","body":"资源防护 通过资源逆向案例我们见识了abtool强大的资源反编译能力，但是这个时候我们不应该兴奋，而是应该无比忧虑才对：因为第三方工具可以在没有项目仓库权限的情况下轻易获取游戏资源，这些都是项目团队日夜攻坚、长时间累积优化的结果，如果被用于非法目的，对游戏是非常不利的。问题来了：既然ab资源如此容易破解，那么该如何保护游戏资产？ 打包ab资源时关掉TypeTree 我们先来看下ab打包接口 public static AssetBundleManifest BuildAssetBundles( string outputPath, AssetBundleBuild[] builds, BuildAssetBundleOptions assetBundleOptions, BuildTarget targetPlatform); 第三个枚举参数BuildAssetBundleOptions用来控制ab的打包行为，其中枚举值DisableWriteTypeTree可以关闭TypeTree。 /// /// Do not include type information within the AssetBundle. /// DisableWriteTypeTree = 8, 由于abtool绝大部分功能都基于TypeTree，那是不是关闭TypeTree资源就安全了？没那么简单！TypeTree是由Unity生成，换句话说，如果拿到相同版本的Unity也是可以轻易获取TypeTree的，在这种情况下，关掉TypeTree的意义仅仅是防止了破解MonoBehaviour，防护等级是很弱的！换句话说，如果你用了Unity公开发行的版本（标准版），那么你的的游戏资产完全是在裸奔的！ 比如王牌战士游戏虽然关闭了资源的TypeTree，但是他们用了标准版的Unity2017.4.26f1 笔者从官网下载了一个相同的安装包，导入资源包QuickStart.unitypackage快速编译出来abtool，同样可以逆向他们的游戏资产。 贴图资源 模型资源 模型+贴图渲染 太恐怖了！如果你的项目选择使用标准版Unity，那么资源被破解几乎是必然的！要想保护游戏资产，那你的项目最好有引擎源码，并从以下几个方向做一些优化，不然是无解的。 修改关键资源序列化 如果你的项目有源码，那么可以把一些关键资源的序列化字段改一下。比如Texture2D这个资源类型，它的数据结构大致如下 struct Texture2D: public Object { std::string m_Name; // 1 int32_t m_ForcedFallbackFormat; // 2 bool m_DownscaleFallback; // 3 int32_t m_Width; // 4 int32_t m_Height; // 5 int32_t m_CompleteImageSize; // 6 int32_t m_TextureFormat; // 7 int32_t m_MipCount; // 8 bool m_IsReadable; // 9 int32_t m_ImageCount; // 10 int32_t m_TextureDimension; // 11 GLTextureSettings m_TextureSettings; // 12 int32_t m_LightmapFormat; // 13 int32_t m_ColorSpace; // 14 TypelessData m_TexData; // 15 StreamingInfo m_StreamData; // 16 }; 在资源对象序列化过程中，string/map/set/vector等数据类型均被当做数组来处理：先用4字节存储数组长度，然后按顺序存储数组元素，对于string它的数组元素类型是char。基于此，我们可以在标准版的Unity源码里面做一些微小改动，比如把上述类型序列化顺序交换位置，或者在这些字段的序列化之前写入一个很大的整形，这样通过标准版Unity反编译资源就会导致崩溃或者无限循环。该保护措施的本质是修改资源类型的数据结构，使其与标准版Unity生成TypeTree产生差异，从而导致通过标准版Unity破解资源的方法失效。 修改AssetBundleArchive存储结构 每个ab资源在Unity里面会都会通过一个AssetBundleArchive容器来存储，它的作用是压缩资源对象数据并提供文件寻址功能，并没有什么特别的，如果你的项目有源码完全可以自行设计一个实现类似功能的资源容器，比如王者荣耀、原神等游戏做了类似的设计。 修改SerializedFile存储结构 除了定制资源容器，还可以通过修改容器内资源的存储方式，比如修改SerializedFile的metadata数据的组织方式。 加密 如果觉得上述源码修改过于复杂，那么可以对ab文件做二进制的加密，也可以选择对其部分内容做加密，前提是不要有过多运行时开销，比如LOL手游做了类似的设计。 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"chaps/cases/crash.html":{"url":"chaps/cases/crash.html","title":"资源引发崩溃","keywords":"","body":"资源引发崩溃 一般情况下资源导致游戏崩溃并不多见，随着游戏资源量的增加以及构建时间的增加，就会需要用到Unity的ab增量编译，但是如果增量编译过程中发生了Unity闪退或者系统崩溃，那么就有很大几率导致编译出来的资源出问题，并且Unity下次构建时也无法自我修复。 举个例子，我们项目的ab资源增加到3G的时候遇到一次比较严重的由热更资源引发的崩溃，由于每次崩溃的时机各有不同，定位起来非常困难，最后通过一个能够稳定复现的崩溃定位到原因是：材质球A引用的贴图T在另外一个ab文件里面，但是通过材质球A的引用路径去加载后得到的是却是另外一个材质球B，可以理解为材质球A的贴图指针位置不是贴图T，那么通过材质球A的贴图指针尝试访问贴图T的时候就崩溃了。然后根据这个特征，笔者开发了scanref工具，它的作用是扫描所有引用了材质球、贴图、Mesh的对象，然后通过引用路径找到目标资源对象，并校验目标资源的类型是否跟预期一致。 图中的日志是什么含义呢？那是纯正的崩溃的味道！ T archive:/cab-935fbd22f82316cda48c391a5d38e03b/cab-935fbd22f82316cda48c391a5d38e03b i:4 Mesh => Texture2D 针对其中一行日志简单解释下，archive:/开头一串文本是ab里面SerializedFile的路径，可以用来寻址。资源dynamic/module/role_bundle_08!7!forcedownload!cod_models$avatar$seal6_003_bluewhite.pak里面id为767的SkinnedMeshRenderer对象拥有一个外部资源指针PPtr，指向另外一个ab资源文件(archive:/cab-935fbd22f82316cda48c391a5d38e03b/cab-935fbd22f82316cda48c391a5d38e03b)中索引为m_PathID=4的对象，但是目标引用路径的资源其实是个Texture2D对象。 上述SkinnedMeshRenderer数据文本展开显示 id=767 m_GameObject:PPtr m_FileID = 0 m_PathID = 169 m_Enabled:bool = 1 m_CastShadows:uint8_t = 1 m_ReceiveShadows:uint8_t = 1 m_ReceiveNoSSShadows:uint8_t = 0 m_DynamicShadows:uint8_t = 1 m_MotionVectors:uint8_t = 2 m_LightProbeUsage:uint8_t = 1 m_ReflectionProbeUsage:uint8_t = 3 m_LightmapIndex:uint16_t = 65535 m_LightmapIndexDynamic:uint16_t = 65535 m_LightmapTilingOffset:Vector4f x:float = 1 y:float = 1 z:float = 0 w:float = 0 m_Materials:vector> [0]:PPtr m_FileID = 0 m_PathID = 3 m_StaticBatchInfo:StaticBatchInfo firstSubMesh:uint16_t = 0 subMeshCount:uint16_t = 0 m_StaticBatchRoot:PPtr m_FileID = 0 m_PathID = 0 m_ProbeAnchor:PPtr m_FileID = 0 m_PathID = 0 m_LightProbeVolumeOverride:PPtr m_FileID = 0 m_PathID = 0 m_SortingLayerID:int32_t = 0 m_SortingLayer:int16_t = 0 m_SortingOrder:int16_t = 0 m_Quality:int32_t = 0 m_UpdateWhenOffscreen:bool = 0 m_SkinnedMotionVectors:bool = 0 m_Mesh:PPtr m_FileID = 4 m_PathID = 4 m_Bones:vector> [0]:PPtr m_FileID = 0 m_PathID = 703 m_BlendShapeWeights:vector m_RootBone:PPtr m_FileID = 0 m_PathID = 703 m_AABB:AABB m_Center:Vector3f x:float = -0.145836 y:float = 0.0210291 z:float = 0.00812059 m_Extent:Vector3f x:float = 0.109583 y:float = 0.15261 z:float = 0.10819 m_DirtyAABB:bool = 0 通过引用路径找到的资源却是Texture2D对象 把Texture2D对象强转成Mesh对象赋值给SkinnedMeshRenderer对象，最终就会导致崩溃。庆幸的现在可以通过abtool scanref扫描游戏的所有资源，30秒就可以扫描3G左右的ab资源，可以说是非常高效的。 find . -iname '*.pak' | xargs abtool scanref scanref会把扫描数据缓存到当前目录的assets.ref文件，下次运行的时候scanref会自动读取缓存文件，这样不用再次扫描ab资源就可以快速得到相同的结果，直接把耗时降到2秒。 abtool scanref 上面的操作还只是发现资源问题，其实我们更想知道这样的问题如何解决，根据问题的严重性有两种解决方法： 如果只有少量ab资源存在引用问题，那么可以把扫描出来的ab资源从构建机的输出目录删掉，下次构建时Unity会修复这些资源； 如果有很多ab资源都存在引用问题，可以通过ab资源回退的方式来解决，前提是每次构建后都归档了相应的ab资源。具体操作是，下载历史构建的ab资源，运行abtool scanref找到一个没有资源引用问题的资源版本，然后用这个版本的ab资源替换构建机上的ab资源，并重新运行一次ab打包流程。 到现在为止，我们知道如何通过abtool发现资源问题，也拥有解决问题的方法，但是相信大家依然会有疑问：资源崩溃问题是如何产生的？ 就上面SkinnedMeshRenderer错误引用Texture2D的例子来说，可以解释为：由于依赖关系变更，A和B两个ab资源都需要重新打包，但是ab资源B打包完成后，由于意外原因导致Unity打包流程中断，本来应该被重新打包的A资源，因为Unity的闪退而被忽略打包，所以A保持为老资源状态并引用了一个错误的资源，并且下次构建的时候Unity也无法识别这种异常情况。 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"chaps/cases/noref.html":{"url":"chaps/cases/noref.html","title":"资源引用丢失","keywords":"","body":"资源引用丢失 在增量编译过程中如果Unity闪退了，除了会产生导致崩溃的问题资源，也会导致一些不那么严重、但是非常奇怪的渲染结果：屏幕渲染出现紫块或者渲染效果异常，通过scanref也可以发现这样的问题，如下日志里面还有missing标记。 屏幕紫块 假如ab资源A引用的材质球M在另外一个ab文件B里面，由于M的打包配置变化导致它应该打包到ab资源C里面，但是由于Unity闪退B和C被正常打包而A没有被正常打包，这种情况下A资源尝试去B资源里面加载M，但是M已经从B里面移除并打包到了C里面，从而出现材质球加载失败的问题，就会出现紫块。 渲染异常 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"chaps/cases/display.html":{"url":"chaps/cases/display.html","title":"资源显示异常","keywords":"","body":"资源显示异常 某天笔者被拉去查一个iOS资源显示问题，如下 正常应该是这样的 从表象来看是图片被横向拉伸了，美术同学和开发同学都说资源没问题，Editor验收也正常，安卓的真机也没问题。如果是你该怎么定位这个问题？ 我来定位的话，就简单多了！工具在手，首先反编译下贴图：通过abtool savetex得到Update_4_1.1024x1024.pvrtc_rgba4.tex，再用textool转码得到tga文件，下图为tga转了jpg的显示。 从结果来看，图片确实被拉伸了，原图是512x1024尺寸的，实际变成1024x1024尺寸了，这是由于PVRTC不支持长方形的贴图导致的：对于非正方形的贴图，会被PVRTC强制拉伸成正方形再进行编码。当然，最终打开Unity那一刻也确认下笔者的判断。 修复也很简单，改成ASTC格式就可以了。 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"chaps/cases/compare.html":{"url":"chaps/cases/compare.html","title":"资源差异比对","keywords":"","body":"资源差异比对 跟进过Unity资源热更发布的朋友就会有感触，每次发布都会自我灵魂拷问：变更的ab资源是否都需要发布？有些资源明确没有改动，但是打出来的ab文件md5却是不同的，该怎么办？不发不放心，发了也不安心！ 那么有了abtool那可就简单多了，通过dump命令把ab文件解压为格式整齐、开发友好的文本文件。 # 当前cd目录为ab资源存储目录 find . -iname '*.pak' | while read pak do abtool dump \"${pak}\" | tee \"${pak}.log\" done 通过上面三行bash脚本可以轻松把所有的ab文件转成文本文件，然后打开BeyondCompare就一切都明了了。对于修改的资源我们会有心理预期，一般比较在意的是预期之外被修改到的资源，据笔者的经验可以大概分为一下几类： 依赖列表顺序 增删进包文件 动画浮点数序列化不稳定 修改MonoBehaviour成员变量 依赖列表顺序 每个ab文件里面都有个AssetBundle对象，其数据结构大致如下 struct AssetBundle { std::string m_Name; // 1 std::vector> m_PreloadTable; // 2 std::multimap m_Container; // 3 AssetInfo m_MainAsset; // 4 uint32_t m_RuntimeCompatibility; // 5 std::string m_AssetBundleName; // 6 std::vector m_Dependencies; // 7 bool m_IsStreamedSceneAssetBundle; // 8 int32_t m_ExplicitDataLayout; // 9 int32_t m_PathFlags; // 10 std::map m_SceneHashes; // 11 }; AssetBundle::m_Dependencies字段存储了当前ab依赖的其他ab文件列表，Unity在打包过程中可能生成不稳定的顺序，但是列表内容相同。 增删进包文件 如果生成ab文件的配置发生了变化，比如增删了文件路径，那么即使游戏资产没变的情况下也会导致ab文件最终发生变化。 动画资产浮点数序列化不稳定 AnimationClip动画资产里面的Hermite样条曲线很容易产生不稳定的结果，主要表现为往极大或者极小值方向变化。 struct StreamedHermiteClip { std::vector data; // 1 uint32_t curveCount; // 2 float timeMin; // 3 std::vector coefMin; // 4 float timeRange; // 5 std::vector coefRange; // 6 }; 修改MonoBehaviour成员变量 MonoBehaviour脚本在序列化的时候会把成员变量按照一定规则算出一个128位的hash值，如果修改了脚本变量那么理论上是不能够热更的，否则运行时将无法对资源进行反序列化和对象加载，一般只有商店版本发布的时候才发布修改后的脚本。 虽然程序版本发布的时候可以修改MonoBehaviour脚本，但是这样一般还会带来有另外一个问题：由于MonoBehaviour的Hash128以及TypeTree会序列化到资源里面，所以修改MonoBehaviour会导致最终的ab资源变更，并且难以发现。笔者基于这种情况，开发了mono命令，可以扫描脚本在ab文件里面的分布情况，简单说可以查看修改某个脚本会影响多少资源的变更。 find . -iname '*.pak' | xargs abtool mono mono命令执行后会把扫描到的数据缓存下来，下次可以直接运行abtool mono而不用再次扫描ab资源。 从扫描结果来看，命名空间GameEngine里面的AssetRef类被174M的ab资源引用，也就是说，修改了AssetRef脚本会导致174M的ab资源发生变化。 在大版本升级过程中我们希望有尽可能多的资源可以复用避免重复下载，那么可以结合cmpmono来对比大版本升级前后有哪些影响ab资源的MonoBehaviour脚本发生了修改。具体做法如下： 分别在需要对比的ab资源目录运行mono命令，这样会生成对应的扫描数据文件monoscripts.ms 运行cmpmono -s [source.ms] -d [destination.ms]输出对比结果 abtool cmpmono -s iMSDK_CN_Android_108_AssetBundle/monoscripts.ms -d iMSDK_CN_Android_145_AssetBundle/monoscripts.ms | grep ^M 这样可以很清晰地看到有多少资源在大版本升级后因为修改MonoBehaviour脚本而发生变化，通过这个列表可以作相应资源优化。 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"chaps/cases/edit.html":{"url":"chaps/cases/edit.html","title":"资源编辑","keywords":"","body":"资源编辑 以下演示继续用战歌竞技场的资源，下面是游戏大厅的界面。 声明：本案例使用的方法以及由该方法得到的资源仅用于学习交流，请勿用于其他非法目的，否则后果自负。 笔者的目标是要把中间那个森林棋盘的Shader去掉，期望棋盘显示为紫色效果。 首先在ab资源里面找到文件dataconfig.god，它看起来像是配置文件，通过list命令发现里面都是二进制配置。 abtool list dataconfig.god 日志中有个dataconfig_chess_board_model_conf.bytes的资源看起来是棋盘相关的配置，我们通过saveta命令提取这些二进制配置，默认输出到__textassets目录。 abtool saveta dataconfig.god 尝试用protoc解析后发现它们都是protobuf序列化的配置文件 protoc --decode_raw 其中pbdecode是笔者写的一个小工具，可以把protoc打印出来的八进制编码转成UTF-8编码，主要方便查看中文配置信息，可以复制以下C++代码自行编译。 #include #include #include void decode(const char *input, char *output, size_t length, bool newline = true) { auto wCursor = output; auto rCursor = input; auto end = rCursor + length; while (rCursor = '0' && *ptr (byte); rCursor += 3; } } ++rCursor; ++wCursor; } *wCursor = 0; std::cout (fs.tellg()); fs.seekg(0); char buffer[length]; fs.read(buffer, length); fs.close(); decode(buffer, buffer, length, false); } int main(int argc, const char * argv[]) { if (argc > 1) { for (auto i = 1; i 然后打开棋盘弹窗，在这里我们知道棋盘的名字叫哥布林部落 同时我们从刚刚解开的配置里面确实找到了相关数据 1 { 1: 18 2: \"哥布林部落\" 3: \"Prefabs/Environment/ChessBoard/ChessBoard_01\" 4: \"Scene_Goblin\" 5: \"DataConfig/CardPoolMat/img_game_chessshop_bg\" 6: \"Prefabs/Environment/Scene/SmallChessBoard/Small_Goblin_01\" 7: 13 8: 101 9: 10501 10: 1002 11: 1001 12: 1003 14: \"map_11_goblin.bnk\" 15: 9027 17: 1 18: 1541462414 19: 1762473614 20: 58 21: 0 22: 60 } 从配置知道这个棋盘的资源名大概是Small_Goblin_01，下面通过list命令穷举所有资源列表。 find . -iname '*.god' | xargs abtool list -r 通过关键字Small_Goblin_01搜索，发现文件名为artresource_environment_scene_logicmesh_small_checkerboard.god的ab可能是我们要找的目标。 但现在还不是特别确定，所以可以先把资源反编译出来确认下，这里使用savetex保存ab里面的贴图，并用textool转码贴图文件，然后可以很容易发现，下面这两张贴图可以确认是大厅棋盘使用的。 棋盘树干以及底座的贴图，可以看出来棋盘的光照是假光照，被烘焙到贴图里面了，如下 棋盘的树叶部分贴图 接下来我们选择与贴图looby_goblin_checkerboard_01.tga同名的材质球looby_goblin_checkerboard_01.mat作为切入点，它的资源ID为7397932659350227505，剩下的工作就交给edit命令来实现了。 abtool edit artresource_environment_scene_logicmesh_small_checkerboard.god 通过上面命令进入交互模式，这里可以执行lua代码，依次输入以下命令得到编辑后的ab文件。 lua so = file:find(7397932659350227505) lua ptr = castMaterial(so.object) lua mat = ptr:get() mat.m_Shader.m_PathID = 0 mat.m_Shader.m_FileID = 0 save 上面的代码每输入一行都要按一次回车键，最终结果是棋盘材质球的Shader引用置空了，最后的save命令会把修改后的ab文件保存到__archives目录，然后把里面的ab文件adb push到游戏的外存储目录，因为一般的热更逻辑是先读外存储的资源，外存储没有才会读安装包里面的资源，这个设计的目的是支持游戏热更。 见证奇迹时刻 上面edit模式需要手动码字，如果需要多次运行的时候就会显得不太方便，那么可以在当前cd目录写一个lua脚本abtool.lua。 -- 通过m_PathID查找SerializedObject对象 trace('原始材质球') so = file:find(7397932659350227505) -- 打印原始材质 file:dump_object(7397932659350227505) -- 类型转换 ptr = castMaterial(so.object) -- std::shared_ptr -- 获取材质球对象引用 mat = ptr:get() -- Material* -- 设置材质的Shader为空引用 mat.m_Shader.m_PathID = 0 mat.m_Shader.m_FileID = 0 -- 打印修改后材质 trace('修改后材质球') file:dump_object(7397932659350227505) -- 保存当前修改 builder = assetbundle.ArchiveFileBuilder(archive) -- assetbundle::ArchiveFileBuilder builder:save(\"hijack/artresource_environment_scene_logicmesh_small_checkerboard.god\") 然后通过lua命令来执行这个脚本。 # 需要把abtool.lua脚本放到当前cd目录 abtool lua artresource_environment_scene_logicmesh_small_checkerboard.god 最终在lua脚本指定的保存目录生成编辑后的ab文件。 当然，这个演示的目的不是教大家hack别人的游戏，由于abtool的这个能力，我们可以通过修改资源快速验证一些想法而不用构建资源包，比如测试发现资源bug，通过abtool快速修复验证，当然前提是你对abtool有一定的熟悉。 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"chaps/cases/missing.html":{"url":"chaps/cases/missing.html","title":"资源引用丢失","keywords":"","body":"资源引用丢失 在增量编译过程中如果Unity闪退了，除了会产生导致崩溃的问题资源，也会导致一些不那么严重、但是非常奇怪的渲染结果：屏幕渲染出现紫块或者渲染效果异常，通过scanref也可以发现问题。 比如上次我们制作了一把KFC主题的战斗刀，Editor里面看到是正常的 但是真机运行的时候就比较奇怪了，明显刀刃的贴图错了，并且刀把的质感也不是特别好。 这种情况下使用scanref检查一遍资源引用，发现了问题 find . -iname '*.pak' | xargs abtool scanref 从日志看，资源dynamic/module/kfc!7!forcedownload!cod_models$weapons$meleeweapon$meleeweapon_014_knifes$cn2!0.pak引用了另外一个ab资源dynamic/module/common!7!forcedownload!cod_models$weapons$meleeweapon$meleeweapon_014_knifes$5!0.pak里面索引为6贴图，但是后者资源里面并没有这个贴图，那么这种情况需要把资源dynamic/module/common!7!forcedownload!cod_models$weapons$meleeweapon$meleeweapon_014_knifes$5!0.pak从构建机删掉重新打包。 定位这个问题，还可以从另外一个角度入手。首先通过saveobj命令保存资源的基本信息。 find . -iname '*.pak' | xargs abtool saveobj 然后通过getref -r命令直接查找出问题的材质球引用的资源列表，其中-r参数表示查找逆向下游资源的引用列表，没有-r参数情况下该命令查找当前资源的上游引用列表。 那么也能发现KnifeS_KFC.mat引用第五个贴图在目标资源dynamic/module/common!7!forcedownload!cod_models$weapons$meleeweapon$meleeweapon_014_knifes$5!0.pak里面找不到，两种方法得到同样结果。 上面被丢失的资源是贴图，如果丢失的资源是材质球，那么就会表现为屏幕紫块，定位方式类似。需要说明的是，上面提到的资源引用丢失问题指的是资源引用在，但是目标资源不存在的情况，如果原始资源引用指针为空，那么这种问题在开发阶段阶段就能发现，当然工具也能发现引用为空的情况。 为了确认资源指针是否为空，我们需要用到另外一个命令edit abtool edit dynamic/module/kfc\\!7\\!forcedownload\\!cod_models\\$weapons\\$meleeweapon\\$meleeweapon_014_knifes\\$cn2\\!0.pak 然后进入命令行交互模式，在这种模式可以执行lua脚本，比如可以输入lua file:dump_object(2)，其中2为KnifeS_KFC.mat的资源索引，通过getref命令得到的。 $ lua file:dump_object(2) id=2 m_Name:string = KnifeS_KFC m_Shader:PPtr m_FileID = 5 m_PathID = 34 m_ShaderKeywords:string = _DYNAMIC_ADVANCE_DETAIL_LERP m_LightmapFlags:uint32_t = 4 m_EnableInstancingVariants:bool = 1 m_DoubleSidedGI:bool = 0 m_CustomRenderQueue:int32_t = -1 stringTagMap:map disabledShaderPasses:vector m_SavedProperties:UnityPropertySheet m_TexEnvs:map first:string = _AlphaMap second:UnityTexEnv m_Texture:PPtr m_FileID = 0 m_PathID = 0 m_Scale:Vector2f x:float = 1 y:float = 1 m_Offset:Vector2f x:float = 0 y:float = 0 first:string = _BentNormalMap second:UnityTexEnv m_Texture:PPtr m_FileID = 0 m_PathID = 0 m_Scale:Vector2f x:float = 1 y:float = 1 m_Offset:Vector2f x:float = 0 y:float = 0 first:string = _BumpMapPakced second:UnityTexEnv m_Texture:PPtr m_FileID = 1 m_PathID = 4 m_Scale:Vector2f x:float = 1 y:float = 1 m_Offset:Vector2f x:float = 0 y:float = 0 first:string = _CutRimTex second:UnityTexEnv m_Texture:PPtr m_FileID = 0 m_PathID = 0 m_Scale:Vector2f x:float = 1 y:float = 1 m_Offset:Vector2f x:float = 0 y:float = 0 first:string = _DetailAlbedoMap second:UnityTexEnv m_Texture:PPtr m_FileID = 4 m_PathID = 3 m_Scale:Vector2f x:float = 3 y:float = 3 m_Offset:Vector2f x:float = -0.15 y:float = 0.8 first:string = _DetailNormalMap second:UnityTexEnv m_Texture:PPtr m_FileID = 0 m_PathID = 0 m_Scale:Vector2f x:float = 1 y:float = 1 m_Offset:Vector2f x:float = 0 y:float = 0 first:string = _EmissionMap second:UnityTexEnv m_Texture:PPtr m_FileID = 0 m_PathID = 0 m_Scale:Vector2f x:float = 1 y:float = 1 m_Offset:Vector2f x:float = 0 y:float = 0 first:string = _HeightMap second:UnityTexEnv m_Texture:PPtr m_FileID = 0 m_PathID = 0 m_Scale:Vector2f x:float = 1 y:float = 1 m_Offset:Vector2f x:float = 0 y:float = 0 first:string = _MainTex second:UnityTexEnv m_Texture:PPtr m_FileID = 1 m_PathID = 5 m_Scale:Vector2f x:float = 1 y:float = 1 m_Offset:Vector2f x:float = 0 y:float = 0 first:string = _MetallicRoughnessMap second:UnityTexEnv m_Texture:PPtr m_FileID = 2 m_PathID = 6 m_Scale:Vector2f x:float = 1 y:float = 1 m_Offset:Vector2f x:float = 0 y:float = 0 first:string = custom_IBLCubemap second:UnityTexEnv m_Texture:PPtr m_FileID = 3 m_PathID = 4 m_Scale:Vector2f x:float = 1 y:float = 1 m_Offset:Vector2f x:float = 0 y:float = 0 在Unity资源里面通过PPtr表示一个资源引用，比如，上面丢失的_MetallicRoughnessMap贴图，它的指针有两个字段：m_FileID表示目标资源的文件索引，m_PathID表示目标资源在目标文件里面的资源索引ID，其中m_FileID可以通过SerializedFile的metadata里面可以索引到一个全局唯一的路径archive:/cab-3fc774b79be2c61a94690dbb2913f522/cab-3fc774b79be2c61a94690dbb2913f522，这样通过m_FileID和m_PathID两个字段可以全局确定一个唯一的资源对象。 first:string = _MetallicRoughnessMap second:UnityTexEnv m_Texture:PPtr m_FileID = 2 m_PathID = 6 m_FileID=0表示当前资源指针指向当前文件内的资源对象，m_PathID=0表示当前资源指针为空，这时通过Unity的Inspector可以看到资源的槽位是空的，所以如果发现某个资源指针的m_PathID=0那么这就是一个资源空引用案例，如下所示。 first:string = _HeightMap second:UnityTexEnv m_Texture:PPtr m_FileID = 0 m_PathID = 0 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"chaps/commands/cmpmono.html":{"url":"chaps/commands/cmpmono.html","title":"cmpmono","keywords":"","body":"cmpmono console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"chaps/commands/getref.html":{"url":"chaps/commands/getref.html","title":"getref","keywords":"","body":"getref 用途 getref加载saveobj生成的数据并通过文件名查找资源对象的上下游引用关系。 参数 参数 缩写 描述 --artifact -a 文件的存储路径，默认：objects.obj --reverse -r 反向查找下游资源引用开关 示例 abtool getref image_icon_kapailv1.mat 从日志可以看出材质球image_icon_kapailv1.mat被两个prefab引用： assets/autogenerate/resources/prefabs/effects/fx_common_upgrade_kapailv1_lod.prefab assets/resources/prefabs/effects/fx_common_upgrade_kapailv1.prefab *-2585818181968686980为资源fx_common_upgrade_kapailv1_lod.prefab在ab资源common_effect.god中的m_PathID。 添加-r参数可以查找被材质球image_icon_kapailv1.mat引用的资源 从日志可以看出材质球image_icon_kapailv1.mat引用了一个shader和一个张贴图。 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"chaps/commands/rename.html":{"url":"chaps/commands/rename.html","title":"rename","keywords":"","body":"rename console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"}}